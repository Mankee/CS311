11/12/2012 – 1:19pm - Dissecting the problem
I started dissecting the assignment and so far I have made the following observations about the threading portion of the assignment. I will use the same method of finding prime numbers as I did in assignment one, however this time I will divide n (the total number of integers specified by the user) into threaded tasks, where each task will find a subtotal of prime numbers in the range of n/(number of threads). Second I will use an array chars to store a 32bit long int for the bitmap. I might represent the bitmap as a two dimensional array that is shared between each task however, this might cause synchronization issues as the number of threads increase. For the threaded portion of the assignment, my design will likely model a Manager/worker threaded program design where a single thread, the manager assigns work to the other threads, the workers. The manager handles all input and parcels out work to the other tasks.

After reading the posix thread tutorial posted on the class website, I think it is worth noting the performace diffrence between forking and thread creation. When compare to the cost of creating and managing a process, a thread can be created with much less operating system overhead. According to the text this is because managing threads requires fewer system resouces than managing processes. A thread duplicates only the essential resources it needs to be independently schedulable by the operating system.

11/12/2012 – 3:55pm - Thinking about bitmaps
After writting some stuff down in my notebook, I realized my char array size will be 1/8th the size of n (range of integers from 0 - n). each bit in my char will be used as a bit marker. for example, lets say I want to find the total number of primes within the the range 1 - 8, n would be size 8. bits 0 , 1, 2, 4, and 6 would all be marked with one to represent prime numbers 1, 2, 3, 5, and 7. This would would give me a decimal value of 87 which I will cast as char to compactly represent my markings. 

It is worth noting that a char is the smallest addressable unit I can use to represent my bitmap. 

11/12/2012 – 5:34pm - Hello World! (threaded)
Huzzah! finished writting my first threaded program. Main creates a number of threads, specified by the user, and each thread prints their id number which was passed as an argument from main. Now I will try passing multiple arguments with a struct, and then attempt using my prime finding function from assighment 1.

11/13/2012 - 7:08am - Passing arguments to threads
I am still confused as the best way to pass arguments to my thread. The pthread tutorials posted on the class website give some good examples however I am not sure which will work best with my design. I am thinking about using a struct to pass each thread their own array of chars to manipulate, a thread id, and possibly a range offset to know what numbers each thread is responsible for checking.

11/13/2012 - 8:30am - Issues determining the total number of needed characters
I just realized that if the total number of needed characters to represent N (the number of integers to check for primes) does not divide evenly by the number of specified threads, one thread will need a larger array of chars than the rest. Of all things I don't know why this is giving me issues. I am thinking about doing a quick check to see if the "total number of needed chars" / "number of specified threads" is greater than zero, meaning the splitting of my bitmap array does not divide evenly, the thread with the most significant bits will get an extra character in it's array. Make sense? Good!

11/13/2012 - 12:30pm - Multiple arguments passed successfully
I decided to make an array of structs to pass multiple arguments to my threads. This will give me the flexibility in the future to add more data to the struct if needed without having to write a bunch of extra code. Plus I think learning how to pass multiple arguments is more challanging and a good thing to know how to do in the future. Next I will be working finding my prime numbers using the algorithm from the first assignment.

11/15/2012 - 10:02am - Algorithms
So I am just now realizing that the algorithm from assignment one is not going to work very well especially now that we are dealing with segmented version of Sieve of Eratosthenes. The algorithm in the first assignment worked just fine because we always started with 2 and moved through the array. However, now that we are dealing with segmented portions of a similar array, it is important to realize that that the starting value is offsetted. Also, not every segmented portion of the array is going to be the same size especially if the number of threads does not divided by the total number of needed characters in the array. After doing a little research online, I discovered that one possible way to deal with this is to mark all the primes up to the square root of n, where n max size of unsigned long long. By marking all non primes up to the square root of n, I can then just mark multiples of of the known primes for each thread to find the rest. My only concern is this portion of my program will be serialized.

11/18/2012 - 1:38am - Finished threaded portion of the program
After many many many hours of blood sweat and tears, I have finally completed the threaded portion of the program. Currently the program computes all 203,280,221 primes in about 101 seconds with a thousand threads. I am almost positive my program would finish in less than 45 seconds if I could figure out how to get rid of the serialized portion of program that computes all the base prime numbers up to the square root of n. I will think on this however, If I dont start the process portion of the program, I am afraid I will not finish in time.

11/19/2012 - 8:37pm - Finished process portion of the program
Just finished the process portion of the program. it was very simple to do, I used the code provided in class to open, truncate, and map my shared memory which is the bitmap array from the threaded protion of the program. Because of my design, I was able to completly avoid using semaphores.
